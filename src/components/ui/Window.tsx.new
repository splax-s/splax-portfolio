import React, { useRef, useState, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import { useOsStore } from '@/store/useOsStore';
import Image from 'next/image';

interface Size {
  width: number | string;
  height: number | string;
}

interface Position {
  x: number;
  y: number;
}

interface WindowProps {
  id: string;
  title: string;
  icon: string;
  children: React.ReactNode;
  initialPosition?: Position;
  initialSize?: Size;
}

const Window: React.FC<WindowProps> = ({
  id,
  title,
  icon,
  children,
  initialPosition = { x: 400, y: 400 },
  initialSize = { width: 600, height: 400 },
}) => {
  // State management
  const windowRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [localSize, setLocalSize] = useState<Size>(initialSize);
  const [currentPosition, setCurrentPosition] = useState<Position>(initialPosition);
  const [resizeDirection, setResizeDirection] = useState<string | null>(null);
  const [startResizePosition, setStartResizePosition] = useState<Position>({ x: 0, y: 0 });
  const [startResizeSize, setStartResizeSize] = useState<Size>(initialSize);

  // Get global state and actions
  const {
    osType,
    windows,
    focusApp,
    closeApp,
    minimizeApp,
    maximizeApp,
    restoreApp,
    moveWindow,
    resizeWindow,
  } = useOsStore();

  const windowData = windows.find(w => w.id === id);
  const isFocused = windowData?.isFocused ?? false;
  const isMaximized = windowData?.isMaximized ?? false;
  const zIndex = windowData?.zIndex ?? 0;

  // Event handlers
  const handleResizeStart = useCallback((direction: string, e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
    setResizeDirection(direction);
    setStartResizePosition({ x: e.clientX, y: e.clientY });
    
    // Set initial size for the resize operation
    const currentWidth = typeof windowData?.size?.width === 'number' ? windowData.size.width : 600;
    const currentHeight = typeof windowData?.size?.height === 'number' ? windowData.size.height : 400;
    const newSize = { width: currentWidth, height: currentHeight };
    
    setStartResizeSize(newSize);
    setLocalSize(newSize);
  }, [windowData?.size]);

  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!isResizing || !resizeDirection) return;

    const deltaX = e.clientX - startResizePosition.x;
    const deltaY = e.clientY - startResizePosition.y;
    
    // Calculate new size and position based on resize direction
    let newSize = { ...localSize };
    let newPosition = { ...currentPosition };

    if (resizeDirection.includes('e')) {
      newSize.width = Math.max(200, Number(startResizeSize.width) + deltaX);
    } else if (resizeDirection.includes('w')) {
      const widthDelta = -deltaX;
      newSize.width = Math.max(200, Number(startResizeSize.width) + widthDelta);
      newPosition.x = currentPosition.x - widthDelta;
    }

    if (resizeDirection.includes('s')) {
      newSize.height = Math.max(200, Number(startResizeSize.height) + deltaY);
    } else if (resizeDirection.includes('n')) {
      const heightDelta = -deltaY;
      newSize.height = Math.max(200, Number(startResizeSize.height) + heightDelta);
      newPosition.y = currentPosition.y - heightDelta;
    }

    setLocalSize(newSize);
    setCurrentPosition(newPosition);
  }, [isResizing, resizeDirection, startResizePosition, startResizeSize, localSize, currentPosition]);

  const handleResizeEnd = useCallback(() => {
    if (isResizing) {
      setIsResizing(false);
      setResizeDirection(null);
      
      // Update the global store with the final size and position
      resizeWindow(id, {
        width: Number(localSize.width),
        height: Number(localSize.height)
      });
      moveWindow(id, currentPosition);
    }
  }, [isResizing, id, localSize, currentPosition, resizeWindow, moveWindow]);

  // Set up event listeners for resize
  useEffect(() => {
    if (isResizing && typeof window !== 'undefined') {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [isResizing, handleResizeMove, handleResizeEnd]);

  // Handle window close animation
  useEffect(() => {
    if (isClosing) {
      const timer = setTimeout(() => {
        closeApp(id);
      }, 200);
      return () => clearTimeout(timer);
    }
  }, [isClosing, closeApp, id]);

  if (!windowData || (!windowData.isOpen && !isClosing)) return null;

  // Calculate final size for display
  const displaySize = isResizing ? localSize : (windowData.size || initialSize);
  const position = isMaximized ? { x: 0, y: 0 } : currentPosition;

  // Resize handle component
  const ResizeHandle = ({ direction }: { direction: string }) => (
    <div
      className={`absolute ${
        direction.includes('s') ? 'bottom-0' : 'top-0'
      } ${
        direction.includes('e') ? 'right-0' : 'left-0'
      } ${
        direction === 'se' ? 'cursor-se-resize' :
        direction === 'sw' ? 'cursor-sw-resize' :
        direction === 'ne' ? 'cursor-ne-resize' :
        'cursor-nw-resize'
      } w-4 h-4 z-50 hover:bg-gray-200 dark:hover:bg-gray-700 opacity-0 hover:opacity-100 transition-opacity`}
      onMouseDown={(e) => handleResizeStart(direction, e)}
    />
  );

  return (
    <motion.div
      ref={windowRef}
      initial={{ scale: 0.9, opacity: 0 }}
      animate={{
        scale: isClosing ? 0.9 : 1,
        opacity: isClosing ? 0 : 1,
        x: position.x,
        y: position.y,
        width: isMaximized ? '100%' : displaySize.width,
        height: isMaximized ? '100%' : displaySize.height,
        zIndex,
      }}
      transition={{
        type: 'spring',
        damping: 20,
        stiffness: 300
      }}
      className="fixed bg-white dark:bg-gray-900 shadow-xl rounded-lg overflow-hidden border border-gray-200 dark:border-gray-800"
      tabIndex={-1}
      onClick={() => focusApp(id)}
    >
      <div className="flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
        <div className="flex items-center gap-2">
          <Image src={icon} alt={title} width={16} height={16} className="w-4 h-4" />
          <span className="font-medium">{title}</span>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={() => minimizeApp(id)}
            className="w-3 h-3 bg-yellow-500 rounded-full hover:bg-yellow-600"
            aria-label="Minimize"
          />
          <button
            onClick={() => isMaximized ? restoreApp(id) : maximizeApp(id)}
            className="w-3 h-3 bg-green-500 rounded-full hover:bg-green-600"
            aria-label="Maximize"
          />
          <button
            onClick={() => setIsClosing(true)}
            className="w-3 h-3 bg-red-500 rounded-full hover:bg-red-600"
            aria-label="Close"
          />
        </div>
      </div>

      <div className="w-full h-full overflow-auto">
        {children}
      </div>

      {!isMaximized && (
        <>
          <ResizeHandle direction="se" />
          <ResizeHandle direction="sw" />
          <ResizeHandle direction="ne" />
          <ResizeHandle direction="nw" />
        </>
      )}
    </motion.div>
  );
};

export default Window;
