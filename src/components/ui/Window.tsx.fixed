import React, { useRef, useState, useEffect, useCallback, useMemo } from 'react';
import { motion } from 'framer-motion';
import { useOsStore } from '@/store/useOsStore';
import { usePreferences } from '@/components/providers/PreferenceProvider';
import { useSound } from '@/components/providers/SoundProvider';
import Image from 'next/image';

interface WindowProps {
  id: string;
  title: string;
  icon: string;
  children: React.ReactNode;
  initialPosition?: { x: number; y: number };
  initialSize?: { width: number; height: number };
}

const Window: React.FC<WindowProps> = ({
  id,
  title,
  icon,
  children,
  initialPosition = { x: 400, y: 400 },
  initialSize = { width: 600, height: 400 },
}) => {
  // State and ref declarations
  const windowRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [isClosing, setIsClosing] = useState(false);
  const [localSize, setLocalSize] = useState(initialSize);
  const [resizeDirection, setResizeDirection] = useState<string | null>(null);

  // Get preferences
  const { motionReduced } = usePreferences();
  const { playSound } = useSound();

  // Store interaction
  const {
    osType,
    windows,
    focusApp,
    closeApp,
    minimizeApp,
    maximizeApp,
    restoreApp,
    moveWindow,
    resizeWindow,
  } = useOsStore();

  // Determine if we're on a mobile device early
  const isMobile = osType === 'ios' || osType === 'android';

  // Memoize values to prevent recreation on each render
  const startResizePosition = useMemo(() => ({ x: 0, y: 0 }), []);
  const startResizeSize = useMemo(() => initialSize, [initialSize]);

  // Window data
  const window = windows.find(w => w.id === id);
  const isFocused = window?.isFocused ?? false;
  const isMaximized = window?.isMaximized ?? false;
  const zIndex = window?.zIndex ?? 0;
  const position = window?.position ?? initialPosition;

  // Utility functions
  const getWindowStyle = () => {
    switch (osType) {
      case 'mac':
        return 'rounded-lg shadow-lg bg-white/90 dark:bg-gray-800/90 backdrop-blur-md border border-gray-200 dark:border-gray-700';
      case 'windows':
        return 'border border-gray-200 dark:border-gray-700 shadow-md bg-white dark:bg-gray-800';
      case 'ios':
        return 'rounded-xl bg-white/95 dark:bg-gray-800/95 backdrop-blur-xl shadow-lg';
      case 'android':
        return 'rounded-lg shadow-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700';
      default:
        return 'border border-gray-200 dark:border-gray-700 rounded-lg shadow-lg';
    }
  };

  const getTitleBarStyle = () => {
    switch (osType) {
      case 'mac':
        return 'bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600 rounded-t-lg';
      case 'windows':
        return 'bg-blue-600 text-white';
      case 'ios':
        return 'bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600 rounded-t-xl';
      case 'android':
        return 'bg-gray-800 text-white rounded-t-lg';
      default:
        return 'bg-gray-100 dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600';
    }
  };

  const getControlButtonStyle = (type: 'minimize' | 'maximize' | 'close') => {
    if (osType === 'mac') {
      switch (type) {
        case 'minimize':
          return 'bg-yellow-500 hover:bg-yellow-600';
        case 'maximize':
          return 'bg-green-500 hover:bg-green-600';
        case 'close':
          return 'bg-red-500 hover:bg-red-600';
        default:
          return '';
      }
    } else if (osType === 'windows') {
      return ''; // Windows uses text buttons
    } else {
      switch (type) {
        case 'minimize':
          return 'bg-gray-400 hover:bg-gray-500';
        case 'maximize':
          return 'bg-gray-400 hover:bg-gray-500';
        case 'close':
          return 'bg-red-500 hover:bg-red-600';
        default:
          return '';
      }
    }
  };

  const getTransition = () => {
    if (motionReduced) {
      return { duration: 0.1 }; // Minimal transition for reduced motion
    }
    
    switch (osType) {
      case 'mac':
        return { type: 'spring', stiffness: 300, damping: 25 };
      case 'windows':
        return { type: 'spring', stiffness: 400, damping: 30 };
      case 'ios':
        return { type: 'spring', stiffness: 350, damping: 25 };
      case 'android':
        return { type: 'spring', stiffness: 400, damping: 30 };
      default:
        return { type: 'spring', stiffness: 300, damping: 25 };
    }
  };

  // Handle window focus
  const handleWindowFocus = useCallback(() => {
    if (!isFocused) {
      focusApp(id);
      playSound('click');
    }
  }, [id, focusApp, isFocused, playSound]);

  // Handle window close
  const handleClose = useCallback(() => {
    setIsClosing(true);
    playSound('windowClose');
    
    // Add a small delay for close animation before actually closing
    setTimeout(() => {
      closeApp(id);
      setIsClosing(false);
    }, 150);
  }, [id, closeApp, playSound]);

  // Handle window minimize
  const handleMinimize = useCallback(() => {
    minimizeApp(id);
    playSound('click');
  }, [id, minimizeApp, playSound]);

  // Handle window maximize/restore
  const handleMaximize = useCallback(() => {
    if (isMaximized) {
      restoreApp(id);
    } else {
      maximizeApp(id);
    }
    playSound('click');
  }, [id, isMaximized, maximizeApp, restoreApp, playSound]);

  // Start dragging the window
  const startDragging = useCallback((e: React.MouseEvent | React.TouchEvent) => {
    e.preventDefault();
    
    // Don't drag if maximized
    if (isMaximized) return;
    
    setIsDragging(true);
    
    let lastClientX: number;
    let lastClientY: number;
    
    if ('touches' in e) {
      // Touch event
      lastClientX = e.touches[0].clientX;
      lastClientY = e.touches[0].clientY;
    } else {
      // Mouse event
      lastClientX = e.clientX;
      lastClientY = e.clientY;
    }
    
    const handleMouseMove = (e: MouseEvent | TouchEvent) => {
      if (!isDragging) return;
      
      let clientX: number;
      let clientY: number;
      
      if ('touches' in e) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      const deltaX = clientX - lastClientX;
      const deltaY = clientY - lastClientY;
      
      if (window && window.position) {
        moveWindow(id, {
          x: window.position.x + deltaX,
          y: window.position.y + deltaY
        });
      }
      
      lastClientX = clientX;
      lastClientY = clientY;
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('touchmove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('touchend', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('touchmove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('touchend', handleMouseUp);
  }, [id, isMaximized, isDragging, moveWindow, window]);

  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!isResizing || !resizeDirection || !window) return;

    const deltaX = e.clientX - startResizePosition.x;
    const deltaY = e.clientY - startResizePosition.y;
    
    let newWidth = startResizeSize.width;
    let newHeight = startResizeSize.height;
    
    if (resizeDirection.includes('e')) {
      newWidth = Math.max(200, startResizeSize.width + deltaX);
    }
    if (resizeDirection.includes('s')) {
      newHeight = Math.max(200, startResizeSize.height + deltaY);
    }
    if (resizeDirection.includes('w')) {
      const widthDelta = -deltaX;
      newWidth = Math.max(200, startResizeSize.width + widthDelta);
      if (window.position) {
        moveWindow(id, { 
          x: window.position.x - widthDelta, 
          y: window.position.y 
        });
      }
    }
    if (resizeDirection.includes('n')) {
      const heightDelta = -deltaY;
      newHeight = Math.max(200, startResizeSize.height + heightDelta);
      if (window.position) {
        moveWindow(id, { 
          x: window.position.x, 
          y: window.position.y - heightDelta 
        });
      }
    }
    
    setLocalSize({ width: newWidth, height: newHeight });
  }, [isResizing, resizeDirection, startResizePosition, startResizeSize, window, moveWindow, id]);

  const handleResizeEnd = useCallback(() => {
    if (isResizing) {
      setIsResizing(false);
      setResizeDirection(null);
      resizeWindow(id, localSize);
    }
  }, [isResizing, resizeWindow, id, localSize]);
  

  // Effects - all before conditional returns
  useEffect(() => {
    if (window && !window.isOpen && !isClosing) {
      setIsClosing(true);
    }
  }, [window, isClosing]);

  useEffect(() => {
    if (isFocused && windowRef.current) {
      windowRef.current.focus();
    }
  }, [isFocused]);

  // When window is opened, play sound effect
  useEffect(() => {
    if (window?.isOpen && isFocused) {
      playSound('windowOpen');
    }
  }, []);

  // Input focus effect for mobile devices
  useEffect(() => {
    if (isMobile && isFocused && inputRef.current) {
      // Short delay to ensure UI has rendered
      setTimeout(() => {
        inputRef.current?.focus();
      }, 100);
    }
  }, [isFocused, isMobile]);

  useEffect(() => {
    if (isResizing && typeof globalThis.window !== 'undefined') {
      globalThis.window.addEventListener('mousemove', handleResizeMove);
      globalThis.window.addEventListener('mouseup', handleResizeEnd);
    }
    return () => {
      if (typeof globalThis.window !== 'undefined') {
        globalThis.window.removeEventListener('mousemove', handleResizeMove);
        globalThis.window.removeEventListener('mouseup', handleResizeEnd);
      }
    };
  }, [isResizing, handleResizeMove, handleResizeEnd]);

  useEffect(() => {
    if (isClosing) {
      const timer = setTimeout(() => {
        closeApp(id);
      }, 200);
      return () => clearTimeout(timer);
    }
  }, [isClosing, closeApp, id]);

  // Only return after all hooks have been called
  if (!window || (!window.isOpen && !isClosing)) return null;

  // Calculate position in the center of the screen for new windows
  const getInitialPosition = () => {
    // Ensure we have access to window object and it's properly defined
    if (typeof globalThis.window === 'undefined') {
      return initialPosition;
    }

    const viewportWidth = globalThis.window.innerWidth || 1024;
    const viewportHeight = globalThis.window.innerHeight || 768;
    
    // Default size for the window
    const defaultWidth = typeof initialSize.width === 'number' ? initialSize.width : 600;
    const defaultHeight = typeof initialSize.height === 'number' ? initialSize.height : 400;
    
    // Center the window both horizontally and vertically
    // Ensure the window is always at least partially visible
    return {
      x: Math.min(Math.max(0, (viewportWidth - defaultWidth) / 2), viewportWidth - 100),
      y: Math.min(Math.max(0, (viewportHeight - defaultHeight) / 2), viewportHeight - 100)
    };
  };
  
  // Use stored position or calculate a centered position
  const windowPosition = window.isMaximized 
    ? { x: 0, y: 0 } 
    : window.position 
      ? {
          x: Math.min(Math.max(0, window.position.x), globalThis.window?.innerWidth - 100 || 0),
          y: Math.min(Math.max(0, window.position.y), globalThis.window?.innerHeight - 100 || 0)
        }
      : getInitialPosition();
    
  const windowSize = window.isMaximized
    ? { width: '100%', height: '100%' }
    : window.size || localSize;

  // Use local state during resize to avoid animation lag
  const displaySize = isResizing ? localSize : windowSize;
  
  // Handle window controls based on OS type
  const renderWindowControls = () => {
    switch (osType) {
      case 'mac':
        return (
          <div className="flex space-x-2">
            <button
              onClick={handleClose}
              className="w-3 h-3 bg-red-500 rounded-full hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500"
              aria-label="Close"
            />
            <button
              onClick={handleMinimize}
              className="w-3 h-3 bg-yellow-500 rounded-full hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500"
              aria-label="Minimize"
            />
            <button
              onClick={handleMaximize}
              className="w-3 h-3 bg-green-500 rounded-full hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500"
              aria-label={isMaximized ? "Restore" : "Maximize"}
            />
          </div>
        );
        
      case 'windows':
        return (
          <div className="flex">
            <button
              onClick={handleMinimize}
              className="px-3 py-1 hover:bg-gray-300 dark:hover:bg-gray-700 focus:outline-none"
              aria-label="Minimize"
            >
              _
            </button>
            <button
              onClick={handleMaximize}
              className="px-3 py-1 hover:bg-gray-300 dark:hover:bg-gray-700 focus:outline-none"
              aria-label={isMaximized ? "Restore" : "Maximize"}
            >
              □
            </button>
            <button
              onClick={handleClose}
              className="px-3 py-1 hover:bg-red-500 hover:text-white focus:outline-none"
              aria-label="Close"
            >
              ×
            </button>
          </div>
        );
        
      default:
        return (
          <button
            onClick={handleClose}
            className="p-2 focus:outline-none"
            aria-label="Close"
          >
            ×
          </button>
        );
    }
  };
  
  if (isMobile) {
    // For mobile OS, we render a full-screen modal with specific OS styling
    const iosStyles = osType === 'ios' ? {
      header: 'bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700',
      closeBtn: 'text-blue-500 font-medium px-3 py-1',
      content: 'bg-white dark:bg-gray-900',
      initial: { y: '100%' },
      animate: { y: 0 },
      exit: { y: '100%' },
      transition: { type: 'spring', damping: 25, stiffness: 300 }
    } : {
      header: 'bg-gray-800 text-white',
      closeBtn: 'text-white rounded-full w-8 h-8 flex items-center justify-center',
      content: 'bg-gray-100 dark:bg-gray-900',
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0, scale: 0.95 },
      transition: { duration: 0.2 }
    };
    
    return (
      <motion.div
        ref={windowRef}
        className="fixed inset-0 z-50 flex flex-col"
        initial={iosStyles.initial}
        animate={iosStyles.animate}
        exit={iosStyles.exit}
        transition={iosStyles.transition}
        onClick={() => {
          focusApp(id);
          // Try to focus any input element when the window is tapped
          const inputs = document.querySelectorAll('input, textarea');
          if (inputs.length > 0) {
            (inputs[0] as HTMLElement).focus();
          }
        }}
        tabIndex={0}
      >
        <motion.div 
          className={`flex items-center justify-between p-2 ${iosStyles.header}`}
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.1, duration: 0.3 }}
        >
          <div className="flex items-center">
            <motion.img 
              src={icon} 
              alt={title} 
              className="w-5 h-5 mr-2"
              initial={{ scale: 0.8, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ delay: 0.2, duration: 0.3 }}
            />
            <h2 className="font-medium">{title}</h2>
          </div>
          <motion.button
            onClick={handleClose}
            className={iosStyles.closeBtn}
            aria-label="Close"
            whileTap={{ scale: 0.95 }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.3 }}
          >
            {osType === 'ios' ? 'Done' : '×'}
          </motion.button>
        </motion.div>
        <motion.div 
          className={`flex-1 overflow-auto ${iosStyles.content}`}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.2, duration: 0.3 }}
        >
          {children}
        </motion.div>
        
        {/* Bottom Pill for iOS */}
        {osType === 'ios' && (
          <motion.div 
            className="flex justify-center py-2"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4 }}
          >
            <div className="w-32 h-1 bg-gray-300 dark:bg-gray-600 rounded-full" />
          </motion.div>
        )}
        
        {/* Android Back Button */}
        {osType === 'android' && (
          <motion.div
            className="absolute bottom-4 left-1/2 transform -translate-x-1/2"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.4, type: "spring" }}
          >
            <button
              onClick={handleClose}
              className="w-12 h-12 rounded-full bg-gray-800 flex items-center justify-center"
              aria-label="Back"
            >
              <svg className="w-6 h-6 text-white" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
              </svg>
            </button>
          </motion.div>
        )}
      </motion.div>
    );
  }
  
  // For desktop OS, we render a draggable, resizable window
  return (
    <motion.div
      ref={windowRef}
      className={`absolute overflow-hidden ${getWindowStyle()} ${isClosing ? 'scale-95 opacity-0' : ''}`}
      style={{
        zIndex: zIndex,
        width: isMaximized ? '100%' : displaySize.width,
        height: isMaximized ? '100%' : displaySize.height,
        left: isMaximized ? 0 : windowPosition.x,
        top: isMaximized ? 0 : windowPosition.y,
      }}
      initial={{ scale: 0.95, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.95, opacity: 0 }}
      transition={getTransition()}
      onClick={handleWindowFocus}
      role="dialog"
      aria-labelledby={`window-${id}-title`}
    >
      {/* Window Title Bar */}
      <div
        className={`${getTitleBarStyle()} flex items-center justify-between px-2 py-1 cursor-move select-none`}
        onMouseDown={startDragging}
        onTouchStart={startDragging}
      >
        {/* Window Title and Icon */}
        <div className="flex items-center space-x-2">
          <Image src={icon} alt={title} width={16} height={16} />
          <div id={`window-${id}-title`} className="text-sm font-medium truncate">{title}</div>
        </div>

        {/* Window Controls */}
        {renderWindowControls()}
      </div>

      {/* Window Content */}
      <div className="h-[calc(100%-2rem)] overflow-auto bg-white dark:bg-gray-800 text-black dark:text-white">
        {children}
      </div>

      {/* Resize Handles (only if not maximized) */}
      {!isMaximized && (
        <>
          {/* Right resize handle */}
          <div
            className="absolute top-0 right-0 w-1 h-full cursor-ew-resize hover:bg-blue-400/20"
            onMouseDown={(e) => {
              e.stopPropagation();
              e.preventDefault();
              setIsResizing(true);
              
              const startSize = {
                width: typeof windowSize.width === 'number' ? windowSize.width : 600,
                height: typeof windowSize.height === 'number' ? windowSize.height : 400
              };
              setLocalSize(startSize);
              
              // Update start position for resize calculations
              startResizePosition.x = e.clientX;
              startResizePosition.y = e.clientY;
              
              // Set direction for resize
              setResizeDirection('e');
            }}
          />
          
          {/* Bottom resize handle */}
          <div
            className="absolute bottom-0 left-0 w-full h-1 cursor-ns-resize hover:bg-blue-400/20"
            onMouseDown={(e) => {
              e.stopPropagation();
              e.preventDefault();
              setIsResizing(true);
              
              const startSize = {
                width: typeof windowSize.width === 'number' ? windowSize.width : 600,
                height: typeof windowSize.height === 'number' ? windowSize.height : 400
              };
              setLocalSize(startSize);
              
              // Update start position for resize calculations
              startResizePosition.x = e.clientX;
              startResizePosition.y = e.clientY;
              
              // Set direction for resize
              setResizeDirection('s');
            }}
          />
          
          {/* Corner resize handle */}
          <div
            className="absolute bottom-0 right-0 w-6 h-6 cursor-se-resize flex items-center justify-center hover:bg-blue-400/20"
            onMouseDown={(e) => {
              e.stopPropagation();
              e.preventDefault();
              setIsResizing(true);
              
              const startSize = {
                width: typeof windowSize.width === 'number' ? windowSize.width : 600,
                height: typeof windowSize.height === 'number' ? windowSize.height : 400
              };
              setLocalSize(startSize);
              
              // Update start position for resize calculations
              startResizePosition.x = e.clientX;
              startResizePosition.y = e.clientY;
              
              // Set direction for resize
              setResizeDirection('se');
            }}
          >
            <svg width="6" height="6" viewBox="0 0 6 6" className="opacity-50">
              <rect x="0" y="3" width="3" height="1" fill="currentColor" />
              <rect x="3" y="0" width="1" height="3" fill="currentColor" />
              <rect x="3" y="3" width="3" height="1" fill="currentColor" />
              <rect x="0" y="4" width="1" height="2" fill="currentColor" />
              <rect x="4" y="0" width="2" height="1" fill="currentColor" />
            </svg>
          </div>
        </>
      )}
    </motion.div>
  );
};

export default Window;
